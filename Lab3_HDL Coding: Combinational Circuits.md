### Кодування на HDL: Комбінаторні схеми
**Проф. Л. Беніні, Ф. Гюркаянк, М. Корб**  
**Остання зміна:** 2024-09-17 10:30:19 +0200

#### Нагадування:
Починаючи це навчання, ви підтверджуєте, що розумієте та приймаєте правила використання установок CAE/CAD програмного забезпечення в ETH Zurich. З ними можна ознайомитись у будь-який час на [eda.ee.ethz.ch](http://eda.ee.ethz.ch/index.php/Regulations).

### 1 Вступ
У цій вправі ви будете використовувати основні концепції мови опису апаратного забезпечення SystemVerilog (HDL) для чисто комбінаторних схем. Зокрема, ви дізнаєтеся:
- як описувати логічні функції, такі як AND та OR,
- як працювати з типами даних у SystemVerilog,
- як реалізовувати комбінаторні блоки, наприклад мультиплексор,
- як створювати ієрархічні архітектури з допомогою модулів, і
- як реалізовувати прості арифметичні функції, такі як множення і додавання.

Вправа розрахована на виконання протягом двох післяобідніх сесій. Разом ми реалізуємо відеопроцесор реального часу HDMI на вашій платі Zybo Z7. Ми припускаємо, що ви вже знайомі з процесом проектування і реалізації FPGA, але може бути корисно ознайомитися з аркушем вправи 1. Під час виконання вправи ви також познайомитеся з симулятором Vivado, який можна використовувати для функціональної перевірки. Ви використовуватимете його з наданим тестовим стендом (розробка власного тестового стенду буде темою вправи 4, і ми не очікуємо, що ви повністю вивчите симулятор після цієї вправи).

Як завжди, ми заохочуємо вас обговорювати будь-які питання, що виникають під час виконання вправи, з асистентами.

### 2 Підготовка
Завдання для студента 1 (налаштування): Налаштуйте робочу директорію для цієї вправи, запустивши наш інсталяційний скрипт і перейшовши в новостворену директорію:
```sh
sh > /home/vlsi1/ex2/install.sh
sh > cd ex2
```

### 3 Обробка відео
Перед тим як розпочати реалізацію вашого відеопроцесора, ми надамо вам деякі базові знання з обробки відео. Зокрема, ми коротко пройдемося по основах кольорової моделі червоний-зелений-синій (RGB) та інтерфейсу HDMI. Насамперед важливо зазначити, що відео — це просто послідовність зображень (у контексті обробки відео ці зображення називаються кадрами), а зображення — це просто масив пікселів.

#### 3.1 RGB
Піксель — це найменша адресована точка в растровому зображенні і, для моделі RGB, складається з трьох компонентів (які ще називаються каналами), інтенсивність яких може змінюватися. Чим більше у вас пікселів, тим вища роздільна здатність зображення. RGB — це проста та поширена адитивна кольорова модель: адитивна означає, що канали (червоний, зелений і синій у даному випадку) додаються для зображення кольору пікселя.

### 3.1.1 Глибина кольору
Як і щільність пікселів, глибина кольору є мірою якості зображення. Вона визначає, скільки різних кольорів може бути представлено одним пікселем. Як вже було зазначено, кожен із трьох компонентів пікселя має свою інтенсивність; у цій вправі ми будемо безпосередньо взаємодіяти з ними: кожен канал RGB має 8 біт, отже доступно 256 різних інтенсивностей для кожного з трьох кольорів, які варіюються від 0 (відсутність цього кольору) до 255 (максимальна інтенсивність цього кольору). Завдяки комбінації трьох кольорів ми здатні відтворити \( 2^8 \times 2^8 \times 2^8 = 16,777,216 \) різних кольорів. 

Тож чорний піксель у моделі RGB буде представлений значеннями:

\[
\text{rgb}_{\text{black}} = (0, 0, 0)
\]

де всі канали мають інтенсивність 0. Навпаки, білий піксель буде мати максимальні значення на кожному каналі:

\[
\text{rgb}_{\text{white}} = (255, 255, 255)
\]

а, наприклад, чисто червоний піксель матиме:

\[
\text{rgb}_{\text{red}} = (255, 0, 0)
\]

### 3.2 HDMI
Інтерфейс HDMI (High Definition Multimedia Interface) був представлений у 2002 році для цифрової передачі аудіо- та відеосигналів і з того часу зазнав подальшого розвитку. Він є зворотно сумісним з інтерфейсом DVI (Digital Video Interface) за допомогою простого пасивного адаптера. Хоча інтерфейс пропонує багато режимів та каналів зв'язку, для наших цілей його функціонування можна зрозуміти досить просто.

На Рис. 1 зображені всі сигнали, які потрібно врахувати при реалізації вашої схеми. Найважливішими є дроти RGB, які визначають колір пікселя, як описано раніше. Три сигнали – `hsync`, `vsync` і `vde` – використовуються приймачем (наприклад, дисплеєм) для синхронізації горизонтального та вертикального положення пікселя. У цьому завданні ми просто будемо передавати ці сигнали через процесор і не працюватимемо з ними, хоча дуже важливо забезпечити їхню точну синхронізацію з сигналами RGB.

Сигнали `ready` та `valid` використовуються для узгодженої передачі даних між модулями: приймач пакета даних сигналізує передавачу, що він готовий прийняти новий пакет, через сигнал `ready`, а передавач вказує приймачу наявність нових даних через сигнал `valid`.

### 4. SystemVerilog
Маючи знання з лекції 3, ви повинні бути в змозі написати весь вихідний код для цього завдання. Хороший огляд найважливіших концепцій можна знайти на сторінці Wiki інституту IIS[^1]. Для кращого розуміння також зверніться до розділу 4.3 підручника "Top-Down Digital VLSI Design" від професора Каесліна.

#### 4.1 Рекомендації щодо написання коду
Використання спільних правил для іменування та стилю кодування створює можливість працювати над проєктами інтегральних схем (IC) у всьому світі. Ми настійно рекомендуємо дотримуватися цих правил для будь-якого проєкту, над яким ви працюєте. Ви можете знайти рекомендації, які використовуються в нашому інституті, за посиланням: [https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md](https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md).

#### 4.2 Підтримка SystemVerilog у текстових редакторах
Загалом ми не вимагаємо використовувати конкретний текстовий редактор для виконання завдань, проте робота стане значно простішою, якщо використовувати редактор, який підтримує синтаксис SystemVerilog. Хоча ви можете бути знайомі із сучасними інтегрованими середовищами розробки (IDE), сумною правдою є те, що на сьогодні немає IDE (принаймні за знанням авторів), яка б забезпечувала достатню підтримку для розробки на SystemVerilog. Оскільки розробники мов опису апаратного забезпечення (HDL) працюють із безліччю скриптових мов і текстових файлів, потужний багатофункціональний текстовий редактор є оптимальним вибором. Хоча більш потужні редактори, такі як `vim`, `Emacs`, є менш зручними для новачків у порівнянні з `Gedit` або `Notepad++`, вони можуть значно підвищити ефективність роботи після набуття певних навичок. Вивчення принаймні одного текстового редактора з керуванням з клавіатури — це добре проведений час для кожного інженера.

##### 4.2.1 Emacs
В інституті IIS ми підтримуємо налаштування для текстового редактора Emacs, що є безкоштовним і з відкритим кодом, яке містить усі необхідні компоненти. Це налаштування включає додаткові пакети для автоматичної перевірки синтаксису, сучасний графічний інтерфейс і деякі більш дружні до початківців стандартні параметри. Це дає змогу відразу почати користуватися редактором, не заглиблюючись у складну систему налаштувань оригінальної версії Emacs. Ви можете встановити ці налаштування, виконавши таку команду в терміналі:

```
sh > /home/vlsi1/emacs-systemverilog/install.sh
```

Встановлення може тривати кілька хвилин. Під час завершення процесу Emacs запуститься в терміналі для виконання ініціалізаційних скриптів. Дочекайтеся, доки Emacs самостійно завершить роботу! Ігноруйте можливі попередження на кшталт `Error while dumping Spacemacs` і просто дочекайтеся, поки Emacs закриється самостійно. Встановлення буде завершено, коли в терміналі з’явиться повідомлення `All done`. Після завершення процедури встановлення обов’язково відкрийте новий термінал і виконайте:

```
sh > emacs <some-file-to-open>
```

Якщо все пройшло успішно, ви побачите інструкцію з використання налаштованої версії Emacs. Якщо ви загубилися в інтерфейсі `Spacemacs`, ви завжди можете знайти посібник із швидкого старту та шпаргалку в меню `IIS Students` у верхньому лівому куті.

> Примітка: Набір налаштувань для студентів і процедура встановлення є відносно новими. Будемо вдячні за будь-які відгуки про помилки, виявлені під час встановлення, та зручність використання.

[^1]: [SystemVerilog Example на Wiki](http://eda.ee.ethz.ch/index.php?title=SystemVerilog_Example).

### Рисунок 2: Огляд ієрархії блоків, що використовуються для обробки відео в цих завданнях

#### 4.2.2 Sublime Text
Якщо ви вже використовуєте Sublime Text — комерційний багатофункціональний текстовий редактор — ми рекомендуємо встановити плагін SystemVerilog для Sublime Text. Удома можна встановити його як звичайний пакет через PackageControl. Тут, у лабораторії, потрібно вручну скопіювати його через Git:

```sh
sh > cd ~/.config/sublime-text/Packages
sh > git clone https://github.com/TheClams/SystemVerilog
sh > cd ~/ex2/
```

Після цього можна запустити Sublime Text, ввівши таку команду в терміналі:

```sh
sh > sublime_text
```

**Завдання для студента 2 (Налаштування редактора):**
- Виберіть один із зазначених вище редакторів, встановіть налаштування для SystemVerilog і ознайомтесь з його інтерфейсом.
- Відкрийте один із файлів SystemVerilog у папці `part1/sourcecode` і переконайтесь, що редактор виділяє синтаксис HDL-коду.

### 5. Ознайомлення з проєктом
На попередньому занятті ви навчились створювати новий проєкт у Vivado. Ми зазначали, що гарною практикою є створення скрипта для прискорення ініціалізації нового проєкту. Цього разу ми вже підготували необхідні скрипти для вас. Ці скрипти створять новий проєкт під назвою `ex2-part1` і імпортують усі вже створені вихідні дані. Вони також встановлять зв'язки між модулями для створення повноцінної функціональної схеми.

**Завдання для студента 3 (Налаштування проєкту):** Перейдіть до папки `part1/vivado` і виконайте `Makefile`:

```sh
sh > cd part1/vivado
sh > make
```

Через кілька секунд ви побачите блокову схему відеопроцесора з трьома основними модулями, як показано на Рисунку 1. Якщо натиснути на вкладку `Sources` у середньому стовпці екрана, ви зможете перейти до різних вихідних файлів. Ви побачите, що структура ієрархічна, як і на Рисунку 2.

![Figure 3: Схема буферизації та функції обходу в rgb_proc_wrap.](#)

Під час цього завдання вам не потрібно звертати увагу на модулі `hdmi_rx`, `hdmi_tx` та `zybo_top`. Вони використовуються для роботи з фізичними інтерфейсами HDMI і для зручного відображення HDMI-сигналу у форматі, що легко модифікується.

Може здатися дивним, що для архітектури, яка складається лише з трьох модулів (як показано на Рисунку 1), використовується так багато файлів. Однак більшість із них застосовуються всередині модуля `rgb_proc_wrap`. `rgb_proc_wrap` є обгорткою навколо основного модуля обробки RGB, `rgb_proc`, який ви створите. Обгортка (wrapper) можна вважати модулем, що робить внутрішній модуль сумісним із навколишньою схемою, але не додає додаткового функціоналу. `rgb_proc_wrap` виконує три завдання:

1. Забезпечує два незалежні шляхи сигналу: один через `rgb_proc`, а інший обходить його. Як показано на Рисунку 3, обхід контролюється вхідним сигналом `enable_i`, який підключений до перемикача 3 (лівий перемикач на платі). Тобто, для тестування `rgb_proc` вам потрібно ввімкнути перемикач 3; якщо ваш модуль спотворює вихідний сигнал, ви завжди можете обійти його, вимкнувши перемикач 3. Таким чином, у більшості випадків вам не доведеться відключати FPGA від монітора, якщо вихідні дані пошкоджені.

2. Буферизує всі сигнали, що надходять від `hdmi_rx` до `hdmi_tx`, щоб `rgb_proc` був послідовно розділений, і у вас був повний тактовий цикл для найтривалішого шляху (ви дізнаєтесь більше про таймінги та найдовші шляхи в Завданні 3).

3. Це модуль Verilog, який всередині викликає SystemVerilog-модуль `rgb_proc`, оскільки Vivado не може безпосередньо викликати модулі SystemVerilog у блок-схемах.

Тепер розглянемо функціональність модуля `rgb_proc`.



