## 1 Вступ

У цьому завданні ви ознайомитеся з основами верифікації та створення тестбенчів. Тестування і верифікація є, мабуть, найтривалішим етапом у типовому життєвому циклі проєкту VLSI (Very-Large-Scale Integration). Успішна верифікація може заощадити значні кошти, оскільки допомагає виявити всі можливі помилки в дизайні до розгортання продукту. Витрати, пов'язані з необхідністю повторного запуску апаратного проєкту, є дуже значними. Тому важливо володіти мистецтвом верифікації, щоб завершити проєкт вчасно. Хоча існує кілька різних аспектів верифікації, у цьому завданні ми зосередимося на *функціональній верифікації*, яка перевіряє логічну поведінку схеми відповідно до специфікацій.

Це завдання займає два дні. Під час цих двох сесій ми проведемо вас через наступні завдання:
1. Ознайомлення з анатомією загальної інфраструктури тестбенча.
2. Написання скриптів для симуляції в ModelSim - просунутому симуляторі HDL.
3. Налагодження дизайну за допомогою ModelSim.
4. Розгляд різних підходів до функціональної верифікації, їх переваг та недоліків.
5. Розробка компонентів тестбенча з використанням SystemVerilog і MATLAB.
6. Використання тверджень (assertions) SystemVerilog для верифікації.

Як завжди, асистенти доступні для допомоги з виконанням завдань та обговорення рішень.

## 2 Підготовка

Щоб отримати доступ до матеріалів, необхідних для цього завдання, виконайте наступне:

**Завдання студента 1 (Налаштування)**: Налаштуйте робочу директорію для цього завдання, викликавши наш скрипт встановлення та перейшовши до новоствореної директорії:
```sh
> /home/vlsi1/ex4/install.sh
> cd ex4
```

## 3 Анатомія тестбенча

Середовище, створене для верифікації проєкту, що тестується (Design Under Test, DUT), називається *тестбенчем*. Типова структура базового тестбенча схематично представлена на Рисунку 1. DUT – це цифрова схема, написана інженером-дизайнером з використанням однієї з мов опису апаратури (HDL), наприклад, VHDL або Verilog. Як показано на рисунку, DUT є частиною тестбенча, а також оточений іншими компонентами тестбенча. Більшість або всі компоненти тестбенча написані з використанням мови опису апаратури (HDL), щоб мати можливість взаємодіяти з DUT. Як показано на Рисунку 1, деякі компоненти тестбенча можуть бути описані з використанням процедурної мови програмування, такої як MATLAB, Python або C/C++, що надає гнучкість для написання складних функціональних специфікацій, потенційно за коротший час. Це означає, що всі компоненти тестбенча (крім DUT) можуть бути *несинтезованими*, щоб оптимізувати час симуляції.

На Рисунку 1 можна побачити наступні компоненти тестбенча:

1. **Генератор стимулів**:
   Цей модуль відповідає за генерацію стимулів для заданого тестового випадку. Вихід генератора стимулів є послідовністю векторів симуляції, які передаються до драйвера застосування на інтерфейсі вводу DUT.

2. **Еталонна модель (Golden Model)**:
   Цей модуль містить точне уявлення про функціональні характеристики DUT.


   Рисунок 1: Загальна архітектура тестбенча

Рисунок 1: Загальна архітектура тестбенча

3. **Драйвер застосування**:
   Цей модуль відповідає за передачу векторів симуляції до DUT. Він забезпечує передачу даних згідно з визначеним протоколом, який може включати складні транзакції, що тривають декілька циклів і потребують внутрішніх станів. У випадках, коли протокол інтерфейсу простіший, функціональність драйвера застосування може бути об'єднана з функціональністю генератора стимулів.

4. **Монітор захоплення (Acquisition Monitor)**:
   Завданням монітора захоплення є моніторинг вихідних відповідей та керування зовнішніми сигналами на вихідному інтерфейсі DUT. Він також збирає вихідні вектори з DUT і передає їх до модуля перевірки (Checker).

5. **Модуль перевірки (Checker)**:
   Модуль перевірки порівнює буферизовані еталонні вихідні вектори з еталонної моделі (Golden Model) з фактичними відповідями, отриманими від монітора захоплення. Він повідомляє про будь-які невідповідності у вихідних даних.

Спочатку ми розглянемо базовий проєкт простого Gray-лічильника, щоб ознайомитися з основними інструментами та аспектами верифікації. Пізніше ми перейдемо до складнішого проєкту фільтра для обробки зображень, щоб випробувати більш просунуті методи верифікації, такі як верифікація на основі випадкових обмежень.
