

### 1 Вступ
У цій вправі ви ознайомитесь з основами роботи з платою розробки програмованої логічної інтегральної схеми (FPGA). Спочатку ви отримаєте загальне уявлення про те, що потрібно для опису апаратного дизайну на FPGA. Далі ви пройдете кроки розгортання базового дизайну на FPGA, дослідите його функціональність та зрозумієте його компоненти. Нарешті, ви перевірите свої знання, взявши інший дизайн, який додає нову функціональність, але також містить деякі недоліки. Ви розгорнете цей дизайн і виправите його, щоб він працював правильно.

Більшість запитань у цій вправі сформульовані відкрито, оскільки вони стосуються принципів і концепцій, а не конкретних рішень. Щоб забезпечити найкращий навчальний досвід, обговорюйте виникаючі запитання та свої відповіді на проблеми з одним із асистентів час від часу. Активна комунікація з викладачами є ключем до успішного виконання вправи.


### 2 Підготовка
#### Завдання 1 (Налаштування):
Налаштуйте робочий каталог для цієї вправи, виконавши наш інсталяційний скрипт і перейшовши до щойно створеного каталогу:
```bash
sh > /home/vlsi1/ex1/install.sh  
sh > cd ex1
```

### 3 Опис апаратного забезпечення на FPGA
Перед тим, як зануритись у використання інструментів, розглянемо короткий огляд опису апаратного забезпечення на FPGA.

#### 3.1 Ресурси FPGA
Кожна FPGA складається з фіксованого набору базових елементів різних типів. Налаштовуючи та з'єднуючи ці елементи у власний спосіб, ви, як розробник апаратного забезпечення, можете реалізувати користувацькі дизайни на готовій FPGA.

Xilinx Zynq-7020 System-on-Chip (SoC), з яким ви працюєте, має п'ять різних типів базових елементів FPGA: конфігуровані логічні блоки (CLB), блочні запам'ятовуючі пристрої з довільним доступом (BRAM), блоки цифрової обробки сигналів (DSP), блоки введення/виведення (IOB) та ресурси тактування. На рисунку 1а показано структуру FPGA серії Xilinx 7, які мають однакові елементи з родиною Zynq-7000. FPGA організована у кілька областей тактування (шість блоків на рисунку), кожна з яких містить 50 CLB. Основна обробка виконується CLB та DSP, які працюють із BRAM, але розуміння ресурсів введення/виведення та тактування також є важливим. Нижче подано короткий огляд кожного типу елементів.

#### 3.1.1 Конфігурований логічний блок (CLB)
Кожен CLB складається з двох логічних слайсів. Спрощену діаграму слайсу CLB показано на рисунку 1b. Кожен слайс містить:
- Чотири таблиці відповідностей (LUT) з шістьма незалежними входами та двома незалежними виходами. LUT може реалізовувати будь-яку булеву функцію своїх входів, зберігаючи та обчислюючи таблицю істинності функції.
- Вісім тригерів (FF), які можуть зберігати виходи LUT.
- Один 4-бітний арифметичний ланцюжок переносу.
- Чотири 1-бітні функціональні мультиплексори.

Від 25 до 50 % усіх слайсів можуть використовувати кожен зі своїх LUT як 64 × 1-бітну розподілену пам’ять, як 32-бітний регістр зсуву або як два 16-бітні регістри зсуву. Ця меншість слайсів належить до типу SLICEM (оптимізована для пам'яті), тоді як більшість належать до типу SLICEL (оптимізована для логіки). Інструменти синтезу враховують властивості та індивідуальні можливості кожного слайсу та автоматично намагаються використовувати їх оптимальним чином.

> Для отримання додаткової інформації див. посібник користувача для конфігурованого логічного блоку FPGA серії 7 від Xilinx (UG474).

### 3.1.2 Блоки оперативної пам’яті з довільним доступом (BRAM)
Кожен BRAM зберігає до 36 Кібіт даних. У типовій конфігурації BRAM містить 1024 записи, кожен з яких має ширину 36 біт (32 біти плюс один біт парності на байт). BRAM дуже гнучкий у налаштуванні кількості записів і ширини кожного запису. У режимі з двома портами — інтерфейс якого показано на рис. 1c — кожен BRAM має два незалежні порти з вхідними даними (32+4) біти, можливістю байтового запису, 16-бітною адресою, вихідними даними (32+4) біти та окремими сигналами тактування, скидання і включення.

### 3.1.3 Цифровий сигналопроцесорний (DSP) блок
Основна функціональність DSP-блоку показана на рис. 1d. Кожен блок включає 25×18-бітний множник з доповненням до двійкового коду, 48-бітний акумулятор, 25-бітний передаддер, додатковий логічний блок для генерації до 10 різних логічних функцій для двох операндів та детектор шаблонів для округлення. Кожен DSP-блок також містить додаткові вхідні, конвеєрні та вихідні регістри. Для повної швидкості операцій множення та накопичення необхідно щонайменше три конвеєрні регістри.

### 3.1.4 Блоки введення/виведення (IOB)
Існує два типи блоків введення/виведення (IOB): високопродуктивні (HP) та широкодіапазонні (HR). HP-блоки розроблені для задоволення вимог високошвидкісної пам'яті та інших інтерфейсів між чіпами з напругою до 1,8 В. HR-блоки підтримують ширший діапазон стандартів введення/виведення з напругою до 3,3 В. IOB також мають можливість програмування затримки введення/виведення, серіалізатори/паралелізатори та програмовану опорну напругу.

### 3.1.5 Ресурси тактування
FPGA має три рівні тактування: входи, що підтримують тактування, глобальні та регіональні ресурси тактування. Зовнішній тактовий сигнал подається через спеціальні входи, які забезпечують швидкісний доступ до глобальних ресурсів тактування через спеціальні лінії передачі. Глобальні ресурси тактування складаються з тактового модуля керування (CMT) та глобальних буферів тактування, які створюють копії вхідного тактового сигналу для кількох навантажень з мінімальними перешкодами та швидким перехідним процесом.

### 3.2 Процес проєктування та впровадження FPGA
Рисунок 2 показує процес проєктування FPGA від специфікацій користувача до налаштування FPGA.

Ви проведете значну частину курсу на етапі перетворення алгоритму в апаратну архітектуру, описану на рівні регістрів (RTL). Для одного алгоритму може бути безліч різних апаратних архітектур, кожна з яких має свої компроміси. Як тільки апаратну частину описано, можливості змін властивостей фінального обладнання обмежені.

Світло-сірі блоки представляють етапи, які проходить ваше проєктування перед впровадженням на FPGA. У цьому завданні ви пройдете ці етапи. Хоча більшість з них автоматизовані, важливо розуміти їхню суть і як це впливає на проєктування. Розглянемо кожен етап.

#### 3.2.1 Розробка
Під час цього етапу генерується нетліст з логічних і арифметичних елементів на основі опису RTL. Наприклад, додавання двох сигналів перетворюється в суматор із відповідними входами. Цей етап не залежить від технології. Розробка нетліста займає кілька хвилин і зазвичай триває лічені секунди для невеликих проєктів.

#### 3.2.2 Синтез
Під час синтезу нетліст прив'язується до елементів обраної родини FPGA. Інструменти також надають перші оцінки використання ресурсів і часу виконання проєкту. Якщо оцінки значно відхиляються від вимог, потрібно внести зміни в опис RTL.

#### 3.2.3 Впровадження
На цьому етапі синтезований нетліст розміщується на фізичних елементах FPGA і маршрутизуються сигнали між ними. Інструменти намагаються мінімізувати затримки сигналу, але це може бути складно на щільно завантажених FPGA. Якщо дизайн не відповідає вимогам щодо ресурсів чи часу, необхідно внести зміни в RTL. 

#### 3.2.4 Генерація бістріму
Бістрім — це послідовність бітів, яка конфігурує транзистори FPGA. Під час цього етапу бістрім генерується на основі впровадженого нетліста.


### 3.3 Передача даних до і з FPGA
FPGA обмінюється даними з периферійними пристроями через порти введення/виведення (I/O), яких у них досить багато. Наприклад, навіть відносно невеликий пристрій, який є перед вами, має 100 користувацьких конфігурованих портів введення/виведення. На платі розробки більшість портів підключені до периферійних пристроїв. Серед них є як прості периферії, такі як кнопки, перемикачі та світлодіоди, так і складніші пристрої, такі як пам'ять, інші інтегральні схеми, порти для високошвидкісної передачі даних (наприклад, Ethernet, USB), а також відеопорти (один HDMI вхід і один вихід).

Ці різноманітні периферійні пристрої мають різні електричні вимоги до струму та напруги, а також до часу. Крім того, одна FPGA повинна мати можливість працювати з різними пристроями та друкованими платами.

Щоб забезпечити таку гнучкість, I/O ресурси FPGA мають високий рівень конфігурації (як коротко згадувалося у розділі 3.1.4). Ця конфігурація визначається на етапі проєктування у файлі з обмеженнями. У цьому файлі також визначаються внутрішні імена для сигналів на I/O-виводах.

### 4 Програмування плати розробки FPGA
Більшість плат для розробки FPGA мають джампери для встановлення або розриву з'єднань на друкованій платі. Щоб уникнути пошкодження плати, завжди перевіряйте правильність налаштувань джамперів перед підключенням її до будь-яких пристроїв.

На платі Zybo джампери використовуються для вибору джерела живлення (варіанти: розетка, програмувальний USB-порт або батарея) і джерела бістріму FPGA (варіанти: SD-карта, флеш через QSPI або JTAG). Ми будемо живити Zybo через програмувальний USB-порт і завантажувати бістрім через робочу станцію, підключену до JTAG.

#### Завдання студента 2 (Контроль і налаштування джамперів):
Перед підключенням плати FPGA переконайтеся, що джампери налаштовані так:
- Джампер вибору живлення, JP6 (у верхньому лівому куті), має бути встановлений на USB, тобто має з'єднувати VU5V0 з USB.
- Джампер режиму програмування, JP5 (у верхньому правому куті), має бути встановлений на JTAG, тобто в крайнє праве положення.

#### Завдання студента 3 (Підключення плати):
Підключіть USB-кабель до роз'єму PROG UART на платі FPGA і до одного з передніх USB-портів вашої робочої станції. Увімкніть плату та переконайтеся, що світлодіод PGOOD загорівся та постійно світиться.

FPGA тепер готова до програмування. Ми будемо використовувати середовище розробки Xilinx Vivado для завантаження вступного дизайну.

#### Завдання студента 4 (Запуск Vivado):
У вашій папці ex1 перейдіть до папки `intro/vivado` і запустіть Xilinx Vivado 2017.2 командою:

```sh
vivado-2017.2 vivado
```

Ви потрапите на екран привітання Vivado. Інструмент має меню зверху, велику робочу область посередині (де відображаються загальні точки входу та останні проєкти), а також консоль унизу.

Як і більшість інструментів для автоматизованого проєктування, Vivado можна керувати через графічний інтерфейс (GUI) або через вбудовану консоль Tcl (мова сценаріїв для командного інтерпретатора). GUI зазвичай є більш інтуїтивним, але для автоматизації повторюваних завдань можна використовувати консоль. Vivado показує команди, які відповідають вашим діям у GUI, у консолі синім кольором.

### Примітка 1 (Рекомендації щодо використання GUI і консолі в інструментах CAE/CAD):
Використовуйте GUI та консоль доповнюючи одне одного. Коли ви виконуєте завдання вперше, використовуйте GUI. Команди, які відповідають вашим діям, з’являються в консолі. Якщо вам потрібно автоматизувати ці дії, збережіть команди у файл сценарію.

#### Завдання студента 5 (Створення сценарію для Vivado):
Створіть файл `intro/vivado/init_proj.tcl` і відкрийте його в редакторі. Під час виконання дій у GUI стежте за командами, які відображаються в консолі Vivado, та додавайте їх до цього файлу. Цей сценарій пізніше буде використовуватися для налаштування нового проєкту.

#### Завдання студента 6 (Створення нового проєкту Vivado):
- У вікні Quick Start натисніть **Create Project**.
- Натисніть **Next**, назвіть проєкт "intro" та переконайтеся, що він буде створений у папці `intro/vivado`.
- На наступному екрані оберіть **RTL Project** та переконайтеся, що **Do not specify sources at this time** не вибрано.
- Натисніть **Next**, додайте папку `intro/sourcecode` як джерело.
- Переконайтеся, що обрані налаштування відповідно до інструкцій, і завершіть створення проєкту.

#### Завдання студента 7 (Вибір стратегії синтезу та впровадження):
Перейдіть до налаштувань проєкту та виберіть стратегію **Flow_RuntimeOptimized** для синтезу та впровадження.

#### Завдання студента 8 (Генерація бістріму):
Запустіть генерацію бістріму через меню **Generate Bitstream** і налаштуйте максимальну кількість паралельних процесів.

#### Завдання студента 9 (Програмування FPGA):
Підключіться до плати через **Open Hardware Manager** і натисніть **Program Device**, щоб запрограмувати FPGA.

